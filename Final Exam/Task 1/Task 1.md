# Task 1: Encrypted Messaging App Prototype - Explanation

This task demonstrates a hybrid encryption system combining RSA and AES to securely send a message from User B to User A.

## Encryption Flow (User B)

1.  **Obtain Recipient's Public Key**: User B needs User A's RSA public key. (In this simulation, it's generated by User A and directly used by User B).
2.  **Generate Symmetric Key**: User B generates a unique, random symmetric key for AES-256. This key will only be used for this single message session.
3.  **Encrypt Message**: User B encrypts the actual secret message (`message.txt`) using AES-256 in GCM mode with the generated symmetric key and a random nonce. AES-GCM is chosen because it provides both confidentiality (encryption) and integrity/authenticity (prevents tampering). The output is `encrypted_message.bin`, containing the nonce followed by the ciphertext.
4.  **Encrypt Symmetric Key**: User B encrypts the *AES session key* using User A's RSA public key with OAEP padding. RSA is suitable for encrypting small amounts of data like a symmetric key. The output is `aes_key_encrypted.bin`.
5.  **Send Data**: User B sends `encrypted_message.bin` and `aes_key_encrypted.bin` to User A.

## Decryption Flow (User A)

1.  **Receive Data**: User A receives the two files: `encrypted_message.bin` and `aes_key_encrypted.bin`.
2.  **Decrypt Symmetric Key**: User A uses their *RSA private key* to decrypt `aes_key_encrypted.bin`. This recovers the original AES session key that User B generated. This step only works if the correct private key corresponding to the public key used for encryption is available.
3.  **Decrypt Message**: User A reads the nonce from the beginning of `encrypted_message.bin`. Then, using the *decrypted AES key* and the nonce, User A decrypts the rest of `encrypted_message.bin` using AES-GCM.
4.  **Obtain Original Message**: If the decryption is successful (meaning the AES key was correct and the data wasn't tampered with, thanks to GCM's integrity check), the result is the original plaintext message, which is saved to `decrypted_message.txt`.

## Why Hybrid Encryption?

* **Efficiency**: AES (symmetric) is much faster than RSA (asymmetric) for encrypting large amounts of data.
* **Key Management**: RSA solves the problem of securely exchanging the symmetric key. Encrypting the bulk message directly with RSA would be very slow and often impractical due to message size limitations of RSA padding schemes.

This approach leverages the speed of symmetric encryption for the message data and the secure key exchange capability of asymmetric encryption for the session key.